{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Swift Package Manager For Kotlin Multiplatform","text":"<p>The Swift Package Manager for Kotlin Multiplatform Plugin, aka <code>spmForKmp</code> Gradle Plugin, is an alternative of the dying CocoaPods Plugin used by KMP cocoapods plugin.</p> <p>It will help you to integrate Swift Package and simplify communication between Swift/Kotlin Multiplatform projects targeting the Apple platform.</p> <p>The plugin uses the embedded Swift Package Manager, so no third-party dependency is needed, and it's less intrusive than CocoaPods.</p> <p>Please Be Aware</p> <p>Pure Swift packages can't be exported to Kotlin; the plugin will help you to create a bridge to bypass this issue.</p> <p>It's a manual job, but until the Swift-import is (not currently planned) available in KMP, it's the only way.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Create a Swift&lt;-&gt;Kotlin bridge: Import your own Swift code for functionality that can't be done in Kotlin.</li> <li>Use SPM third-Party Dependency: Add external dependency and use it inside your bridge</li> <li>Import Swift-compatible code to Kotlin: Enable SPM dependencies and your own Swift code to be exposed directly in your Kotlin code (if compatible).</li> </ul>"},{"location":"#support-my-project","title":"Support My Project \u2b50\ufe0f","text":"<p>If you find this project useful, please consider giving it a star!</p> <p></p>"},{"location":"#feedback","title":"Feedback","text":"<p>This project greatly needs feedback, feature requests, and information about the edge case for progressing; let's talk.</p>"},{"location":"#example","title":"Example","text":"<p>A sample is available for people wanted to see the usage.</p>"},{"location":"bridge/","title":"Bridge The Native API","text":""},{"location":"bridge/#gradle","title":"Gradle","text":"<p>The following configuration is a simple bridge between Kotlin and the Swift Apple Native SDK.</p> build.gradle.kts<pre><code>swiftPackageConfig {\n    create(\"[cinteropName]\") {\n    }\n}\n</code></pre> <p>When syncing the project, the plugin creates a folder at <code>src/swift/[cinteropname]</code>.</p> <p>The content of this folder is your bridge between Swift and Kotlin, it can contain only Swift source files or no file.</p>"},{"location":"bridge/#example","title":"Example","text":"<p>Make your Swift code compatible with Kotlin.</p> <p>Your Swift code needs to be marked as @objc/@objcMembers and the visibility set as <code>public</code> or it won't be exported and available from your Kotlin code.</p> <p>Some tips here.</p> src/swift/[cinteropname]/mySwiftFile.swift<pre><code>import UIKit\n\n@objcMembers public class MySwiftBridge: NSObject {\n    public func exportedMethod() -&gt; String {\n        return \"value\"\n    }\n    public func exportedView() -&gt; NSObject {\n        return UIView()\n    }\n}\n</code></pre> iosMain/kotlin/com/example/myKotlinFile.kt<pre><code>import [cinteropname].MySwiftBridge\n\nval contentFromSwift = MySwiftBridge().exportedMethod()\n\nval aView = MySwiftBridge().exportedView() as UIView\n</code></pre>"},{"location":"bridgeWithDependencies/","title":"Use External Dependencies","text":""},{"location":"bridgeWithDependencies/#how-it-works","title":"How It works","text":"<p>On completion with the basic configuration, it's possible to use external dependency with your bridge.</p> <p>The Plug-in reproduces the CocoaPods plugin behavior with the same kind of issues about third-party dependency but less intrusively.</p> <p>Note</p> <p>If your package doesn't work with the plugin, please create an issue.</p>"},{"location":"bridgeWithDependencies/#supported-dependency-sources","title":"Supported Dependency Sources","text":"<p>The plugin supports the following configurations :</p> VersionCommitBranchLocal <pre><code>SwiftDependency.Package.Remote.Version(\n    url = URI(\"https://github.com/krzyzanowskim/CryptoSwift.git\"),\n    version = \"1.8.4\",\n    products = {\n        add(\"CryptoSwift\")\n    },\n)\n</code></pre> <pre><code>SwiftDependency.Package.Remote.Commit(\n    url = URI(\"https://github.com/krzyzanowskim/CryptoSwift.git\"),\n    revision = \"729e01bc9b9dab466ac85f21fb9ee2bc1c61b258\",\n    products = {\n        add(\"CryptoSwift\")\n    },\n)\n</code></pre> <pre><code>SwiftDependency.Package.Remote.Branch(\n    url = URI(\"https://github.com/krzyzanowskim/CryptoSwift.git\"),\n    branch = \"main\",\n    products = {\n        add(\"CryptoSwift\")\n    },\n),\n</code></pre> <pre><code>SwiftDependency.Package.Local(\n    path = \"Absolute path to the local package folder\",\n    packageName = \"LocalSourceDummyFramework\",\n    products = {\n        add(\"LocalSourceDummyFramework\")\n    },\n),\n</code></pre> Local Binary <pre><code>SwiftDependency.Binary.Local(\n    path = \"/path/to/LocalFramework.xcframework\"\n    packageName = \"LocalFramework\"\n),\n</code></pre> Remote Binary <pre><code>SwiftDependency.Binary.Remote(\n    url = URI(\"https://.../RemoteBinaryFramework.xcframework.zip\"),\n    checksum = \"[checksum]\",\n    packageName = \"RemoteBinaryFramework\",\n)\n</code></pre> <p>SwiftDependency reference</p>"},{"location":"bridgeWithDependencies/#xcframework","title":"XCFramework","text":"<p>The XCFramework are used for Local/Remote Binary and protecting source code distribution, learn more.</p> <p>An example is available.</p>"},{"location":"bridgeWithDependencies/#gradle","title":"Gradle","text":"<p>The following configuration imports the package CryptoSwift which is a pure Swift library, that can't be used directly in Kotlin. build.gradle.kts<pre><code>swiftPackageConfig {\n    create(\"[cinteropName]\") {\n        dependency(\n            SwiftDependency.Package.Remote.Version(\n                url = URI(\"https://github.com/krzyzanowskim/CryptoSwift.git\"),\n                products = {\n                    add(\"CryptoSwift\")\n                },\n                version = \"1.8.4\",\n            ),\n            // Another SwiftDependency\n            // ...\n        )\n    }\n}\n</code></pre></p> <p>Warning</p> <p>A local swift package is being generated during the build and this message diplayed <pre><code>Spm4Kmp: A local Swift package has been generated at\n/path/to/the/local/package\nPlease add it to your xcode project as a local package dependency.\n</code></pre> Add the folder to your Xcode project as a Local package, that's all.</p> <p>Note : When updating your configuration, reset the package cache to apply the modification.</p>"},{"location":"bridgeWithDependencies/#example","title":"Example","text":"<p>Make your Swift code compatible with Kotlin.</p> <p>Your Swift code needs to be marked as @objc/@objcMembers and the visibility set as <code>public</code> or it won't be exported and available from your Kotlin code.</p> src/swift/[cinteropname]/mySwiftFile.swift<pre><code>import Foundation\nimport CryptoSwift\n\n@objcMembers public class MySwiftBridge: NSObject {\n    public func toMD5(value: String) -&gt; String {\n        return value.md5()\n    }\n}\n</code></pre> iosMain/kotlin/com/example/myKotlinFile.kt<pre><code>import [cinteropname].MySwiftBridge\n\nval contentFromSwift = MySwiftBridge().toMD5(value = \"someString\")\n</code></pre>"},{"location":"exportingDependencies/","title":"Export Dependencies To Kotlin","text":""},{"location":"exportingDependencies/#how-it-works","title":"How It works","text":"<p>On completion with using external dependencies, it's possible to export them to Kotlin, if they are compatible.</p> <p>Exported dependency can be used inside the bridge, the Swift &amp; Kotlin App.</p> <p>Note</p> <p>If your package doesn't work with the plugin, please create an issue.</p>"},{"location":"exportingDependencies/#bridge-incompatible-dependencies","title":"Bridge Incompatible Dependencies","text":"<p>In a case the exported dependency is written in Swift, manual work needs to be done like this.</p> <p>For example, the CryptoSwift can't work directly on Kotlin, so the Plugin's bridge is here to fill the hole between Kotlin and Swift.</p>"},{"location":"exportingDependencies/#gradle","title":"Gradle","text":"<p>The following configuration export to Kotlin the package FirebaseAnalytics which is a ObjC library.</p> <p>Don't export incompatible library</p> <p>Exporting an incompatible library is useless and will only increase build time.</p> build.gradle.kts<pre><code>swiftPackageConfig {\n    create(\"[cinteropName]\") {\n        dependency(\n            SwiftDependency.Package.Remote.Version(\n                url = URI(\"https://github.com/firebase/firebase-ios-sdk.git\"),\n                products = {\n                    add(\"FirebaseAnalytics\", exportToKotlin = true), // exported\n                    add(\"FirebaseCore\") // non-exported\n                },\n                version = \"11.8.0\",\n            ),\n            // Another SwiftDependency\n            // ...\n        )\n    }\n}\n</code></pre> <p>Warning</p> <p>A local swift package is being generated during the build and this message diplayed <pre><code>Spm4Kmp: A local Swift package has been generated at\n/path/to/the/local/package\nPlease add it to your xcode project as a local package dependency.\n</code></pre> Add the folder to your Xcode project as a Local package, that's all.</p> <p>Note : When updating your configuration, reset the package cache to apply the modification.</p>"},{"location":"exportingDependencies/#example","title":"Example","text":"iosMain/kotlin/com/example/myKotlinFile.kt<pre><code>import FirebaseAnalytics.FIRConsentStatusGranted\n\n@ExperimentalForeignApi\nval consentStatusGranted = FIRConsentStatusGranted\n</code></pre> <p>Note</p> <p>The bridge can remain empty as we don't need it; we only want to use the exported product.</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#whats-a-pure-swift-package","title":"What's a Pure Swift Package ?","text":"<p>The Pure word means the Package is written only in Swift, like 90% of the existing package.</p> <p>The Swift language is commonly used in the Apple Platform and is not compatible with KMP, but only with ObjC.</p> <p>Unlike Kotlin with Java, the interoperability between Swift and ObjC needs to be explicitly declared, but it's like a downgrade, and nobody want to do that.</p> <p>Some old libraries, like Firebase, are mainly written in ObjC or a few of them want to have the compatibility with ObjC.</p> <p>So mainly, Apple's Platforms libraries are written in Swift; you can check inside their repository, the\u00a0Languages\u00a0section to see which language they are using.</p> <p>But sometimes, like google nearby, a wrapper Swift &lt;- ObjC is made to increase the compatibility with Swift and make it unexportable to Kotlin.</p>"},{"location":"faq/#when-exporting-a-product-i-have-only-swift_typedefs-or-swift_-available-in-my-kotlin-code","title":"When exporting a product I have only SWIFT_TYPEDEFS or swift_... available in my Kotlin code.","text":"<p>That means your product is not compatible with ObjC.</p> <p>During the compilation of the package, the Swift compiler generates an ObjC header with all compatible code.</p> <p>The exported ObjC code can be found inside <pre><code>[project]/build/spmKmpPlugin/[cinteropName]/scratch/release/[product].build/module.modulemap\n</code></pre></p> <p>or</p> <pre><code>[project]/build/spmKmpPlugin/[cinteropName]/scratch/release/[product].framework/Modules/module.modulemap\n</code></pre> <p>This module contains every available ObjC header inside the Package.</p> <p>A Pure Swift package has only generic content like <code>SWIFT_TYPEDEFS</code>.</p>"},{"location":"issues/","title":"Known Issues","text":""},{"location":"issues/#coming-not-soon","title":"Coming (not?) soon","text":""},{"location":"license/","title":"License","text":"<p>The MIT License (MIT) Copyright (c) 2025 Fran\u00e7ois Dabonot</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"setup/","title":"Getting Started","text":""},{"location":"setup/#requirement","title":"Requirement","text":"<ul> <li>Macos With Xcode 16 and later</li> <li>Kotlin : 2.1.0 and later</li> <li>Gradle : 8.10 and later</li> </ul>"},{"location":"setup/#plugins","title":"Plugins","text":"build.gradle.kts<pre><code>plugins {\n    id(\"org.jetbrains.kotlin.multiplatform\")\n    id(\"io.github.frankois944.spmForKmp\") version \"[version]\"\n}\n</code></pre>"},{"location":"setup/#gradle-properties","title":"Gradle Properties","text":"gradle.properties<pre><code>kotlin.mpp.enableCInteropCommonization=true\n</code></pre>"},{"location":"setup/#initial-configuration","title":"Initial Configuration","text":"build.gradle.kts<pre><code>kotlin {\n    listOf(\n        iosArm64(),\n        iosSimulatorArm64()\n        // and more Apple targets...\n    ).forEach {\n        it.compilations {\n            val main by getting {\n                // Choose the cinterop name\n                cinterops.create(\"[cinteropName]\")\n            }\n        }\n    }\n}\n</code></pre> <p>swiftPackageConfig reference build.gradle.kts<pre><code>swiftPackageConfig {\n    create(\"[cinteropName]\") { // must match with cinterops.create name\n    }\n}\n</code></pre></p>"},{"location":"tips/","title":"Tips","text":""},{"location":"tips/#reduce-build-time","title":"Reduce Build Time","text":"<ul> <li>Since the version 0.4.0</li> </ul> <p>spmWorkingPath has been added to change the path to Swift Package working file.</p> <p>By setting spmWorkingPath outside the build folder, the working files won't be removed if you clean the project, and you can exclude the folder from indexing.</p> <p>Swift Package Manager has its own cache, so it's fine to detach it from the Kotlin build folder.</p>"},{"location":"tips/#cicd-caching","title":"CI/CD Caching","text":"<p>Add to your cache the content of the <code>build/spmKmpPlugin</code> folder or the <code>spmWorkingDir</code> value if set.</p> <p>Also, check my GitHub action workflow where I build the example app with cached built files.</p>"},{"location":"tips/#firebase","title":"Firebase","text":"<p>An full example of how to implement Firebase with the plugin</p>"},{"location":"tips/#working-with-objcnamesclasses-types","title":"Working With 'objcnames.classes' Types","text":"<p>For example, when using a UIView (work with any ObjC Types, ex: UIViewController...).</p> <p>mySwiftBridge.swift<pre><code>// Force cinterop to include `platform.UIKit.UIView`\n@objcMembers public class MyDummyView: UIView {}\n\n// Or force by inheritance\n@objcMembers public class TestClass: NSObject /* or UIView */ {\n\n    // return `UIView` is not enough to let cinterop use the correct type\n    public func getView() -&gt; UIView {\n        return UIView()\n    }\n\n    public func setView(view: UIView) {\n        // store view\n    }\n\n    // or if you don't want to declare an extra MyDummyView\n\n    public func getViewWithNSObject() -&gt; NSObject {\n        return UIView()\n    }\n\n    public func setViewWithNSObject(view: NSObject) {\n        // store view\n    }\n\n}\n</code></pre> iosMain/myKotlinFile.kt<pre><code>fun getView(): UIView = TestClass().getView()\nfun setView(view: UIView) = TestClass().setViewWithView(view)\n\n// or\n\nfun getView(): UIView = TestClass().getViewWithNSObject() as UIView\nfun setView(view: UIView) = TestClass().setViewWithNSObject(view)\n</code></pre></p>"},{"location":"references/productName/","title":"ProductName","text":""},{"location":"references/productName/#productname_1","title":"ProductName","text":"<pre><code>/**\n * Represents the name of a product, with an optional alias and more to come.\n *\n * @property name The name of the product within the Swift package ecosystem. This is required for proper\n * identification and resolution of the dependency.\n * @property alias An optional alias that can be used as an alternate reference to the product.\n * Some Package use indirect name for a product.\n * @property linkerOpts Add custom linker flag when exporting the product to kotlin\n * @property compilerOpts Add custom compiler flag when exporting the product to kotlin\n *\n */\npublic data class ProductName(\n    val name: String,\n    val alias: String? = null,\n    var linkerOpts: List&lt;String&gt; = emptyList(),\n    var compilerOpts: List&lt;String&gt; = emptyList(),\n) : Serializable\n</code></pre>"},{"location":"references/productPackageConfig/","title":"ProductPackageConfig","text":""},{"location":"references/productPackageConfig/#add-by-productname","title":"Add by ProductName","text":"<pre><code>/**\n* Adds one or more products to the product package configuration.\n*\n* @param products The products to be added. Each product is represented by a [ProductName],\n* which includes details such as the name and an optional alias.\n* @param exportToKotlin Determines whether the added products should be exported\n* to Kotlin. Defaults to `false` if not specified.\n*/\npublic fun add(\n    vararg products: ProductName,\n    exportToKotlin: Boolean = false,\n)\n</code></pre>"},{"location":"references/productPackageConfig/#add-by-names","title":"Add by Names","text":"<pre><code>/**\n * Adds one or more product names to the product package configuration using their string representation.\n *\n * @param names The string representations of the product names to be added.\n * Each string corresponds to the name of the product within the Swift package ecosystem.\n * @param exportToKotlin Determines whether the added products should be exported\n * to Kotlin. Defaults to `false` if not specified.\n */\npublic fun add(\n    vararg names: String,\n    exportToKotlin: Boolean = false,\n)\n</code></pre>"},{"location":"references/swiftDependency/","title":"SwiftDependency","text":""},{"location":"references/swiftDependency/#swiftdependencypackage","title":"SwiftDependency.Package","text":""},{"location":"references/swiftDependency/#remote","title":"Remote","text":""},{"location":"references/swiftDependency/#version","title":"Version","text":"<pre><code>/**\n * Represents a specific version of a remote Swift package to be used\n * as a dependency in a Kotlin Multiplatform project.\n *\n * @property url The URL of the remote Git repository where the package is hosted.\n * @property products A list of the product's package used during dependency configuration.\n * @property packageName The name of the package, by default base of the url.\n * @property version The specific version of the Swift package to be imported.\n */\nSwiftDependency.Package.Remote.Version(\n    public override val url: URI,\n    public override val packageName: String = buildPackageName(url),\n    public val version: String,\n    public override val products: ProductPackageConfig.() -&gt; Unit,\n)\n</code></pre>"},{"location":"references/swiftDependency/#commit","title":"Commit","text":"<pre><code>/**\n * Represents a specific remote commit dependency for a Swift Package.\n *\n * @property url The URL of the remote Git repository where the package is hosted.\n * @property products A list of the product's package used during dependency configuration.\n * @property packageName The name of the package, by default base of the url.\n * @property revision A specific commit hash representing the dependency version.\n */\nSwiftDependency.Package.Remote.Commit(\n    public override val url: URI,\n    public override val packageName: String = buildPackageName(url),\n    public val revision: String,\n    override val products: ProductPackageConfig.() -&gt; Unit,\n)\n</code></pre>"},{"location":"references/swiftDependency/#branch","title":"Branch","text":"<pre><code>/**\n * Represents a branch-based remote Swift dependency in a Kotlin Multiplatform project.\n *\n * @property url The URL of the remote Git repository where the package is hosted.\n * @property products A list of the product's package used during dependency configuration.\n * @property packageName The name of the package, by default base of the url.\n * @property branch The branch name of the remote Git repository used for the dependency.\n */\nSwiftDependency.Package.Remote.Branch(\n    public override val url: URI,\n    public override val packageName: String = buildPackageName(url),\n    public val branch: String,\n    override val products: ProductPackageConfig.() -&gt; Unit,\n),\n</code></pre>"},{"location":"references/swiftDependency/#local","title":"Local","text":"<pre><code>/**\n * Represents a local Swift package dependency.\n *\n * @property path The local file URL (file://...) to the local Swift package folder.\n * @property packageName The name of the package, by default the first product name.\n * @property products A list of the product's package used during dependency configuration.\n */\nSwiftDependency.Package.Local(\n    val path: String,\n    override var packageName: String = \"\", // by default the first ProductName\n    override val products: ProductPackageConfig.() -&gt; Unit,\n),\n</code></pre>"},{"location":"references/swiftDependency/#binary","title":"Binary","text":""},{"location":"references/swiftDependency/#local_1","title":"Local","text":"<pre><code>/**\n * Represents a local binary dependency in the Kotlin Multiplatform project.\n *\n * @see &lt;a href=\"https://www.avanderlee.com/swift/binary-targets-swift-package-manager/#local-binary-targets\"&gt;How to make one&lt;/a&gt;\n *\n * @property path The local file URL (file://...) to the xcFramework.\n * @property packageName The name of the package associated with this binary.\n * @property exportToKotlin Defines whether the dependency should be exported for use in Kotlin code.\n */\nSwiftDependency.Binary.Local(\n    val path: String,\n    override val packageName: String,\n    override val exportToKotlin: Boolean = false,\n    override var linkerOpts: List&lt;String&gt; = emptyList(),\n    override var compilerOpts: List&lt;String&gt; = emptyList(),\n),\n</code></pre>"},{"location":"references/swiftDependency/#remote_1","title":"Remote","text":"<pre><code>/**\n * Represents a remote binary dependency as a zipped xcFramework\n *\n * @see &lt;a href=\"https://www.avanderlee.com/swift/binary-targets-swift-package-manager/#defining-a-binary-target\"&gt;How to make one&lt;/a&gt;\n *\n * @property url The URL pointing to the remote binary artifact.\n * @property packageName The name of the package associated with this binary dependency.\n * @property exportToKotlin Defines whether this dependency should be exported for use in Kotlin code.\n * @property checksum The checksum of the remote binary to verify its integrity.\n */\nSwiftDependency.Binary.Remote(\n    val url: URI,\n    override val packageName: String,\n    override val exportToKotlin: Boolean = false,\n    val checksum: String,\n    override var linkerOpts: List&lt;String&gt; = emptyList(),\n    override var compilerOpts: List&lt;String&gt; = emptyList(),\n)\n</code></pre>"},{"location":"references/swiftPackageConfig/","title":"SwiftPackageConfig","text":""},{"location":"references/swiftPackageConfig/#custompackagesourcepath","title":"customPackageSourcePath","text":"<pre><code>/**\n* Specifies the custom source path for the Swift package in the Kotlin Multiplatform project.\n*\n* By default, this path is set to the `src/swift` directory within the project's root directory.\n* This property allows defining a different directory for the Swift package source files,\n* enabling customized project structure organization.\n*/\npublic var customPackageSourcePath: String = Path(project.projectDir.path, \"src\", \"swift\").pathString\n</code></pre>"},{"location":"references/swiftPackageConfig/#minios","title":"minIos","text":"<pre><code>/**\n * Specifies the minimum iOS platform version required for the Swift package integration.\n *\n * This property determines the deployment target for the iOS platform when building the Swift package\n * within the Kotlin Multiplatform project. Modifying this value adjusts the generated build configuration\n * and compatibility of the resulting package with iOS devices and emulators.\n *\n * Default value: [DEFAULT_MIN_IOS_VERSION]\n */\npublic var minIos: String = DEFAULT_MIN_IOS_VERSION\n</code></pre>"},{"location":"references/swiftPackageConfig/#minmacos","title":"minMacos","text":"<pre><code>/**\n * Specifies the minimum supported macOS version for the Swift Package Manager (SPM) integration.\n *\n * This property defines the macOS version targeted by the Swift package and its dependencies.\n * Used during the generation of SPM manifests and the compilation of Swift packages to ensure compatibility\n * with the specified macOS version.\n *\n * Default value: [DEFAULT_MIN_MAC_OS_VERSION]\n */\npublic var minMacos: String = DEFAULT_MIN_MAC_OS_VERSION\n</code></pre>"},{"location":"references/swiftPackageConfig/#mintvos","title":"minTvos","text":"<pre><code>/**\n * Specifies the minimum required version of tvOS for the Swift package definition.\n *\n * This property is used to configure the minimum tvOS version that the Swift package\n * dependencies and targets must support.\n *\n * Default value: [DEFAULT_MIN_TV_OS_VERSION]\n */\npublic var minTvos: String = DEFAULT_MIN_TV_OS_VERSION\n</code></pre>"},{"location":"references/swiftPackageConfig/#minwatchos","title":"minWatchos","text":"<pre><code>/**\n * Minimum watchOS version required for the Swift package.\n *\n * This variable is used to specify the minimum version of watchOS that a Swift package targets\n * when building or running tasks involving watchOS-specific code. It ensures compatibility\n * with the defined platform version during build processes or runtime configurations.\n *\n * Default value: [DEFAULT_MIN_WATCH_OS_VERSION]\n */\npublic var minWatchos: String = DEFAULT_MIN_WATCH_OS_VERSION\n</code></pre>"},{"location":"references/swiftPackageConfig/#toolsversion","title":"toolsVersion","text":"<pre><code>/**\n * Specifies the version of Swift tools that will be utilized.\n * This version determines the compatibility and features available for the Swift Package Manager.\n *\n * The `toolsVersion` value impacts the structure of the `Package.swift` manifest file and\n * the behavior of the Swift package dependencies during resolution and compilation.\n *\n * Default value: [DEFAULT_TOOL_VERSION]\n */\npublic var toolsVersion: String = DEFAULT_TOOL_VERSION\n</code></pre>"},{"location":"references/swiftPackageConfig/#debug","title":"debug","text":"<pre><code>/**\n * Indicates whether the Swift package is built in debug mode.\n *\n * If set to `true`, the package is being built with debug configuration. This can be useful for\n * testing or development purposes where debug symbols and additional information are required.\n *\n * Note: release build are faster\n *\n * Default value: `false`\n */\npublic var debug: Boolean = false\n</code></pre>"},{"location":"references/swiftPackageConfig/#packagedependencyprefix","title":"packageDependencyPrefix","text":"<pre><code>/**\n * Represents a prefix used for resolving conflicts or distinguishing between multiple\n * package dependencies within a Kotlin Multiplatform project.\n * This variable can be utilized to customize or uniquely identify package names or references when required.\n *\n * It is nullable and, when set, the prefix will be applied to all dependencies.\n */\npublic var packageDependencyPrefix: String? = null\n</code></pre>"},{"location":"references/swiftPackageConfig/#linkeropts","title":"linkerOpts","text":"<pre><code>/**\n *  Add custom linker flag when exporting the product to kotlin\n */\npublic var linkerOpts: List&lt;String&gt; = emptyList()\n</code></pre>"},{"location":"references/swiftPackageConfig/#compileropts","title":"compilerOpts","text":"<pre><code>/**\n *  Add custom compiler flag when exporting the product to kotlin\n */\npublic var compilerOpts: List&lt;String&gt; = emptyList()\n</code></pre>"},{"location":"references/swiftPackageConfig/#dependency","title":"dependency","text":"<pre><code>/**\n * Adds one or more Swift dependencies to the dependencies list.\n *\n * @param dependency A variable number of `SwiftDependency` instances to be added.\n * This can include local or remote dependencies in the form of\n * Swift packages or binary `xcframework` bundles.\n * It supports different dependency models such as local, versioned\n * remote, branch-based remote, or commit-based remote dependencies.\n */\npublic fun dependency(vararg dependency: SwiftDependency)\n</code></pre>"},{"location":"references/swiftPackageConfig/#sharedcachepath","title":"sharedCachePath","text":"<pre><code>/**\n * Represents the file path to the shared cache directory used by the package.\n * This path is utilized for caching purposes to optimize dependency management,\n * reducing redundant network calls or disk operations during the build process.\n * The cache directory can store downloaded Swift package artifacts or other\n * reusable build-related data.\n *\n * If set to `null`, the default cache location will be used, determined\n * by the underlying build tool configuration or environment settings.\n */\npublic var sharedCachePath: String? = null\n</code></pre>"},{"location":"references/swiftPackageConfig/#sharedconfigpath","title":"sharedConfigPath","text":"<pre><code>/**\n * Represents the file path to the shared configuration directory.\n *\n * It is optional and can be set to null if no such shared directory is required or use the default one.\n *\n */\npublic var sharedConfigPath: String? = null\n</code></pre>"},{"location":"references/swiftPackageConfig/#sharedsecuritypath","title":"sharedSecurityPath","text":"<pre><code>/**\n * Specifies the shared directory path for security-related resources or configurations.\n *\n * It is optional and can be set to null if no such shared directory is required or use the default one.\n */\npublic var sharedSecurityPath: String? = null\n</code></pre>"},{"location":"references/swiftPackageConfig/#spmworkingpath","title":"spmWorkingPath","text":"<pre><code>/**\n * The path of the directory where working SPM file(s) will be written.\n *\n * Default : `build/spmKmpPlugin/`\n */\npublic var spmWorkingPath: String? = null\n</code></pre>"},{"location":"usages/distribution/","title":"Distribute Kotlin Library","text":""},{"location":"usages/distribution/#release-a-library-using-the-plugin","title":"Release A Library Using The Plugin","text":"<p>We can distribute to other users a Kotlin library using native or third-party dependency, some requirements are necessary for Apple targets.</p>"},{"location":"usages/distribution/#requirement","title":"Requirement","text":"<p>The user must :</p> <ul> <li>add the same native dependency used by the Kotlin library to his Xcode project.</li> <li>use the same version as the library use.</li> </ul> <p>It will fix issues with linking, missing resources, App Store compliance, and more.</p> <p>Note</p> <p>The user doesn't have access to the Kotlin library source code, which is great!</p>"},{"location":"usages/distribution/#example","title":"Example","text":"<p>A Compose Multiplatform Component library using a native video player.</p> commonMain/kotlin/KmpPlayer.kt<pre><code>@Composable\npublic expect fun KmpPlayer(modifier: Modifier = Modifier, url: String)\n</code></pre>"},{"location":"usages/distribution/#android","title":"Android","text":"<p>For Android, it uses Exoplayer.</p>"},{"location":"usages/distribution/#gradle","title":"Gradle","text":"library/build.gradle.kts<pre><code>androidMain.dependencies {\n    implementation(libs.media3.exoplayer)\n    implementation(libs.media3.exoplayer.dash)\n    implementation(libs.media3.ui)\n}\n</code></pre>"},{"location":"usages/distribution/#androidmain","title":"AndroidMain","text":"androidMain/kotlin/KmpPlayer.kt<pre><code>@Composable\npublic actual fun KmpPlayer(modifier: Modifier, url: String) {\n\n    val context = LocalContext.current\n\n    // Initialize ExoPlayer\n    val exoPlayer = ExoPlayer.Builder(context).build()\n\n    val mediaSource = remember(url) {\n        MediaItem.fromUri(url)\n    }\n\n\n    LaunchedEffect(url) {\n        exoPlayer.setMediaItem(mediaSource)\n        exoPlayer.prepare()\n    }\n\n    // Manage lifecycle events\n    DisposableEffect(Unit) {\n        onDispose {\n            exoPlayer.release()\n        }\n    }\n\n    AndroidView(\n        factory = { ctx -&gt;\n            PlayerView(ctx).apply {\n                player = exoPlayer\n            }\n        },\n        modifier = modifier\n    )\n}\n</code></pre>"},{"location":"usages/distribution/#ios","title":"iOS","text":"<p>For iOS, it uses KSPlayer, it's a pure Swift library.</p>"},{"location":"usages/distribution/#gradle_1","title":"Gradle","text":"library/build.gradle.kts<pre><code>swiftPackageConfig {\n    create(\"appleDeps\") {\n        minIos = \"13.0\"\n        minMacos = \"10.15\"\n        minTvos = \"13.0\"\n        minWatchos = \"2.0\"\n        dependency(\n            SwiftDependency.Package.Remote.Branch(\n                url = URI(\"https://github.com/kingslay/KSPlayer\"),\n                products = {\n                    add(\"KSPlayer\")\n                },\n                branch = \"main\"\n            ),\n        )\n    }\n}\n</code></pre>"},{"location":"usages/distribution/#bridge","title":"Bridge","text":"<p>Some tips here.</p> src/swift/appleDeps/MEPlayerController.swift<pre><code>import Foundation\nimport KSPlayer\n\n@objcMembers public class MEPlayerController: NSObject {\n     private let player = IOSVideoPlayerView()\n\n    override init() {\n       super.init()\n       KSOptions.secondPlayerType = KSMEPlayer.self\n       player.delegate = self\n       player.autoresizingMask = [.flexibleWidth, .flexibleHeight]\n       player.contentMode = .scaleAspectFill\n    }\n\n    public func setMediaItem(videoUrl: URL) {\n       player.set(\n          url: videoUrl,\n          options: KSOptions()\n      )\n    }\n\n    public var playerView: NSObject {\n       player\n    }\n\n    public func releasePlayer() {\n       player.resetPlayer()\n       player.removeFromSuperview()\n    }\n}\n</code></pre>"},{"location":"usages/distribution/#iosmain","title":"IOSMain","text":"iosMain/kotlin/KmpPlayer.kt<pre><code>import appleDeps.MEPlayerController\n\n@Composable\npublic actual fun KmpPlayer(modifier: Modifier, url: String) {\n\n    val playerController = MEPlayerController()\n\n    val mediaSource = remember(url) {\n        NSURL.URLWithString(url)\n    }\n\n    LaunchedEffect(url) {\n        if (mediaSource == null) {\n            throw Exception(\"Bad input URL\")\n        }\n        playerController.setMediaItemWithVideoUrl(videoUrl = mediaSource)\n    }\n\n    DisposableEffect(Unit) {\n        onDispose {\n            playerController.releasePlayer()\n        }\n    }\n\n    UIKitView(\n        factory = {\n            playerController.playerView() as UIView\n        },\n        modifier = modifier,\n        update = {\n        }\n    )\n}\n</code></pre>"},{"location":"usages/distribution/#requirement_1","title":"Requirement","text":"<p>The setup guide of your library must contain the rule that KSPlayer package must be added to his Xcode project with the explicit version.</p>"},{"location":"usages/distribution/#sample","title":"Sample","text":"<p>The sample is available.</p> <ul> <li>Run the command <code>./gradlew publishToMavenLocal --no-configuration-cache</code> on the repository root.</li> <li>Open the project <code>sampleApp</code> and test the application</li> </ul>"},{"location":"usages/largebridge/","title":"Working With Large Bridge","text":"<p>If you plan to have a large bridge for using a particular Pure Swift Package, like Stripe, working with an editor without code completion can be difficult.</p> <p>The solution is to work with a local package you will add to your plugin configuration.</p> <p>The big advantage is that you can test your code before adding it to your KMP project.</p>"},{"location":"usages/largebridge/#create-a-local-package","title":"Create A Local Package","text":"<ul> <li>From command line : <code>swift package init --name YouPackageName</code></li> <li>From Xcode : File -&gt; New -&gt; Package -&gt; Library</li> </ul>"},{"location":"usages/largebridge/#choose-your-editor","title":"Choose Your Editor","text":"<p>You can either use Xcode or VSCode with the Swift Plugin; both are fine.</p>"},{"location":"usages/largebridge/#package-manifest","title":"Package Manifest","text":"<p>A Swift Package is based on a Manifest, the Package.swift (official documentation)</p>"},{"location":"usages/largebridge/#example","title":"Example","text":"Package.swift<pre><code>// swift-tools-version: 5.9\n// The swift-tools-version declares the minimum version of Swift required to build this package.\n\nimport PackageDescription\n\nlet package = Package(\n    name: \"MyStripeSDK\",\n    platforms: [.iOS(.v14)],\n    products: [\n        // Products define the executables and libraries a package produces, making them visible to other packages.\n        .library(\n            name: \"MyStripeSDK\",\n            targets: [\"MyStripeSDK\"]),\n    ],\n    dependencies: [\n        .package(url: \"https://github.com/stripe/stripe-ios-spm\", .upToNextMajor(from: \"24.5.0\")),\n    ],\n    targets: [\n        // Targets are the basic building blocks of a package, defining a module or a test suite.\n        // Targets can depend on other targets in this package and products from dependencies.\n        .target(\n            name: \"MyStripeSDK\",\n            dependencies: [\n                .product(name: \"Stripe\", package: \"stripe-ios-spm\"),\n                .product(name: \"StripePaymentSheet\", package: \"stripe-ios-spm\")\n            ]),\n        .testTarget(\n            name: \"MyStripeSDKTests\",\n            dependencies: [\n                \"MyStripeSDK\"\n            ]\n        ),\n    ]\n)\n</code></pre>"},{"location":"usages/largebridge/#package-source","title":"Package Source","text":"<p>Usually located at <code>Sources/[packageName]</code>, it has the same requirement as the plugin's bridge source files.</p> <p>Make your Swift code compatible with Kotlin.</p> <p>Your Swift code needs to be marked as @objc/@objcMembers and the visibility set as <code>public</code> or it won't be exported and available from your Kotlin code.</p>"},{"location":"usages/largebridge/#example_1","title":"Example","text":"Sources/MyStripeSDK/Package.swift<pre><code>import StripePaymentSheet\n\n@objcMembers public class MyStripeSDK: NSObject {\n\n    private var paymentSheet: PaymentSheet?\n    private var paymentIntentClientSecret: String\n    private let backendCheckoutUrl = URL(string: \"Your backend endpoint/payment-sheet\")\n\n    public init(paymentIntentClientSecret: String) {\n        self.paymentIntentClientSecret = paymentIntentClientSecret\n    }\n\n    public func doStripeJob() {\n        var configuration = PaymentSheet.Configuration()\n        configuration.merchantDisplayName = \"Example, Inc.\"\n        self.paymentSheet = PaymentSheet(paymentIntentClientSecret: self.paymentIntentClientSecret,\n                                         configuration: configuration)\n    }\n}\n</code></pre>"},{"location":"usages/largebridge/#plugin-configuration","title":"Plugin Configuration","text":"<p>Add your local package to your plugin configuration, follow the guide.</p>"},{"location":"usages/largebridge/#example_2","title":"Example","text":"build.gradle.kts<pre><code>swiftPackageConfig {\n    create(\"MyStripeSDKLibs\") {\n        dependency(\n            SwiftDependency.Package.Local(\n                // absolute path to your Local Package\n                path = \"$projectDir/../MyStripeSDK\",\n                packageName = \"MyStripeSDK\",\n                products = {\n                    // Export to Kotlin for use in shared Kotlin code, false by default\n                    add(\"MyStripeSDK\", exportToKotlin = true)\n                },\n            ),\n        )\n    }\n}\n</code></pre>"},{"location":"usages/largebridge/#dont-store-sensitive-data","title":"Don't Store Sensitive Data","text":"<p>The local package source is visible</p> <p>If you share this package, don't put sensitive data inside, as it needs to be added to the Xcode project.</p> <p>You can use the default plugin's bridge if needed, as it's not visible from the application or your shared Kotlin library.</p>"},{"location":"usages/multiTarget/","title":"Multi Target Configuration","text":""},{"location":"usages/multiTarget/#configuration-by-target","title":"Configuration By Target","text":"<p>You can set a different configuration for each target you manage.</p> build.gradle.kts<pre><code>listOf(\n    iosX64(),\n    iosSimulatorArm64(),\n).forEach {\n    it.compilations {\n        val main by getting {\n            cinterops.create(\"nativeIosShared\") // a config for iOS\n        }\n    }\n}\n\nlistOf(\n    macosArm64(),\n).forEach {\n    it.compilations {\n        val main by getting {\n            cinterops.create(\"nativeMacosShared\") // a config for macos\n        }\n    }\n}\n\nswiftPackageConfig {\n    create(\"nativeIosShared\") {\n        // your embedded swift is inside the folder src/swift/nativeIosShared\n        // your config for iOS\n    }\n    create(\"nativeMacosShared\") {\n        // your embedded swift is inside the folder src/swift/nativeMacosShared\n        // your config for macOS\n    }\n}\n</code></pre>"}]}